{
  "version": 3,
  "sources": ["../../@tmcw/togeojson/lib/lib/shared.ts", "../../@tmcw/togeojson/lib/lib/gpx/line.ts", "../../@tmcw/togeojson/lib/lib/gpx/extensions.ts", "../../@tmcw/togeojson/lib/lib/gpx/coord_pair.ts", "../../@tmcw/togeojson/lib/lib/gpx/properties.ts", "../../@tmcw/togeojson/lib/lib/gpx.ts", "../../@tmcw/togeojson/lib/lib/tcx.ts", "../../@tmcw/togeojson/lib/lib/kml/fixColor.ts", "../../@tmcw/togeojson/lib/lib/kml/extractStyle.ts", "../../@tmcw/togeojson/lib/lib/kml/shared.ts", "../../@tmcw/togeojson/lib/lib/kml/geometry.ts", "../../@tmcw/togeojson/lib/lib/kml/placemark.ts", "../../@tmcw/togeojson/lib/lib/kml/ground_overlay.ts", "../../@tmcw/togeojson/lib/lib/kml.ts"],
  "sourcesContent": ["import type { Feature, Geometry } from \"geojson\";\n\nexport function $(element: Element | Document, tagName: string): Element[] {\n  return Array.from(element.getElementsByTagName(tagName));\n}\n\nexport type P = NonNullable<Feature[\"properties\"]>;\nexport type F = Feature<Geometry | null>;\n\nexport type StyleMap = { [key: string]: P };\n\nexport function normalizeId(id: string) {\n  return id[0] === \"#\" ? id : `#${id}`;\n}\n\nexport function $ns(\n  element: Element | Document,\n  tagName: string,\n  ns: string\n): Element[] {\n  return Array.from(element.getElementsByTagNameNS(ns, tagName));\n}\n\n/**\n * get the content of a text node, if any\n */\nexport function nodeVal(node: Element | null) {\n  node?.normalize();\n  return (node && node.textContent) || \"\";\n}\n\n/**\n * Get one Y child of X, if any, otherwise null\n */\nexport function get1(\n  node: Element,\n  tagName: string,\n  callback?: (elem: Element) => unknown\n) {\n  const n = node.getElementsByTagName(tagName);\n  const result = n.length ? n[0] : null;\n  if (result && callback) callback(result);\n  return result;\n}\n\nexport function get(\n  node: Element | null,\n  tagName: string,\n  callback?: (elem: Element, properties: P) => P\n) {\n  const properties: Feature[\"properties\"] = {};\n  if (!node) return properties;\n  const n = node.getElementsByTagName(tagName);\n  const result = n.length ? n[0] : null;\n  if (result && callback) {\n    return callback(result, properties);\n  }\n  return properties;\n}\n\nexport function val1(\n  node: Element,\n  tagName: string,\n  callback: (val: string) => P | void\n): P {\n  const val = nodeVal(get1(node, tagName));\n  if (val && callback) return callback(val) || {};\n  return {};\n}\n\nexport function $num(\n  node: Element,\n  tagName: string,\n  callback: (val: number) => Feature[\"properties\"]\n) {\n  const val = parseFloat(nodeVal(get1(node, tagName)));\n  if (isNaN(val)) return undefined;\n  if (val && callback) return callback(val) || {};\n  return {};\n}\n\nexport function num1(\n  node: Element,\n  tagName: string,\n  callback?: (val: number) => unknown\n) {\n  const val = parseFloat(nodeVal(get1(node, tagName)));\n  if (isNaN(val)) return undefined;\n  if (callback) callback(val);\n  return val;\n}\n\nexport function getMulti(node: Element, propertyNames: string[]): P {\n  const properties: P = {};\n  for (const property of propertyNames) {\n    val1(node, property, (val) => {\n      properties[property] = val;\n    });\n  }\n  return properties;\n}\n\nexport function isElement(node: Node | null): node is Element {\n  return node?.nodeType === 1;\n}\n", "import { get, P, val1, $num } from \"../shared\";\n\nexport function getLineStyle(node: Element | null) {\n  return get(node, \"line\", (lineStyle) => {\n    const val: P = Object.assign(\n      {},\n      val1(lineStyle, \"color\", (color) => {\n        return { stroke: `#${color}` };\n      }),\n      $num(lineStyle, \"opacity\", (opacity) => {\n        return { \"stroke-opacity\": opacity };\n      }),\n      $num(lineStyle, \"width\", (width) => {\n        // GPX width is in mm, convert to px with 96 px per inch\n        return { \"stroke-width\": (width * 96) / 25.4 };\n      })\n    );\n    return val;\n  });\n}\n", "import { isElement, nodeVal } from \"../shared\";\n\nexport type ExtendedValues = [string, string | number][];\n\nexport function getExtensions(node: Element | null): ExtendedValues {\n  let values: [string, string | number][] = [];\n  if (node === null) return values;\n  for (const child of Array.from(node.childNodes)) {\n    if (!isElement(child)) continue;\n    const name = abbreviateName(child.nodeName);\n    if (name === \"gpxtpx:TrackPointExtension\") {\n      // loop again for nested garmin extensions (eg. \"gpxtpx:hr\")\n      values = values.concat(getExtensions(child));\n    } else {\n      // push custom extension (eg. \"power\")\n      const val = nodeVal(child);\n      values.push([name, parseNumeric(val)]);\n    }\n  }\n  return values;\n}\n\nfunction abbreviateName(name: string) {\n  return [\"heart\", \"gpxtpx:hr\", \"hr\"].includes(name) ? \"heart\" : name;\n}\n\nfunction parseNumeric(val: string) {\n  const num = parseFloat(val);\n  return isNaN(num) ? val : num;\n}\n", "import { Position } from \"geojson\";\nimport { num1, get1, nodeVal } from \"../shared\";\nimport { ExtendedValues, getExtensions } from \"./extensions\";\n\ninterface CoordPair {\n  coordinates: Position;\n  time: string | null;\n  extendedValues: ExtendedValues;\n}\n\nexport function coordPair(node: Element): CoordPair | null {\n  const ll = [\n    parseFloat(node.getAttribute(\"lon\") || \"\"),\n    parseFloat(node.getAttribute(\"lat\") || \"\"),\n  ];\n\n  if (isNaN(ll[0]) || isNaN(ll[1])) {\n    return null;\n  }\n\n  num1(node, \"ele\", (val) => {\n    ll.push(val);\n  });\n\n  const time = get1(node, \"time\");\n  return {\n    coordinates: ll,\n    time: time ? nodeVal(time) : null,\n    extendedValues: getExtensions(get1(node, \"extensions\")),\n  };\n}\n", "import { $, getMulti, nodeVal } from \"../shared\";\n\nexport function extractProperties(node: Element) {\n  const properties = getMulti(node, [\n    \"name\",\n    \"cmt\",\n    \"desc\",\n    \"type\",\n    \"time\",\n    \"keywords\",\n  ]);\n\n  const extensions = Array.from(\n    node.getElementsByTagNameNS(\n      \"http://www.garmin.com/xmlschemas/GpxExtensions/v3\",\n      \"*\"\n    )\n  );\n  for (const child of extensions) {\n    if (child.parentNode?.parentNode === node) {\n      properties[child.tagName.replace(\":\", \"_\")] = nodeVal(child);\n    }\n  }\n\n  const links = $(node, \"link\");\n  if (links.length) {\n    properties.links = links.map((link) =>\n      Object.assign(\n        { href: link.getAttribute(\"href\") },\n        getMulti(link, [\"text\", \"type\"])\n      )\n    );\n  }\n\n  return properties;\n}\n", "import type {\n  FeatureCollection,\n  Feature,\n  Point,\n  MultiLineString,\n  LineString,\n  Position,\n} from \"geojson\";\nimport { getLineStyle } from \"./gpx/line\";\nimport { coordPair } from \"./gpx/coord_pair\";\nimport { extractProperties } from \"./gpx/properties\";\nimport { P, $, get1, getMulti } from \"./shared\";\n\n/**\n * Extract points from a trkseg or rte element.\n */\nfunction getPoints(node: Element, pointname: \"trkpt\" | \"rtept\") {\n  const pts = $(node, pointname);\n  const line: Position[] = [];\n  const times = [];\n  const extendedValues: P = {};\n\n  for (let i = 0; i < pts.length; i++) {\n    const c = coordPair(pts[i]);\n    if (!c) {\n      continue;\n    }\n    line.push(c.coordinates);\n    if (c.time) times.push(c.time);\n    for (const [name, val] of c.extendedValues) {\n      const plural =\n        name === \"heart\" ? name : name.replace(\"gpxtpx:\", \"\") + \"s\";\n      if (!extendedValues[plural]) {\n        extendedValues[plural] = Array(pts.length).fill(null);\n      }\n      extendedValues[plural][i] = val;\n    }\n  }\n\n  if (line.length < 2) return; // Invalid line in GeoJSON\n\n  return {\n    line: line,\n    times: times,\n    extendedValues: extendedValues,\n  };\n}\n\n/**\n * Extract a LineString geometry from a rte\n * element.\n */\nfunction getRoute(node: Element): Feature<LineString> | undefined {\n  const line = getPoints(node, \"rtept\");\n  if (!line) return;\n  return {\n    type: \"Feature\",\n    properties: Object.assign(\n      { _gpxType: \"rte\" },\n      extractProperties(node),\n      getLineStyle(get1(node, \"extensions\"))\n    ),\n    geometry: {\n      type: \"LineString\",\n      coordinates: line.line,\n    },\n  };\n}\n\nfunction getTrack(node: Element): Feature<LineString | MultiLineString> | null {\n  const segments = $(node, \"trkseg\");\n  const track = [];\n  const times = [];\n  const extractedLines = [];\n\n  for (const segment of segments) {\n    const line = getPoints(segment, \"trkpt\");\n    if (line) {\n      extractedLines.push(line);\n      if (line.times && line.times.length) times.push(line.times);\n    }\n  }\n\n  if (extractedLines.length === 0) return null;\n\n  const multi = extractedLines.length > 1;\n\n  const properties: Feature[\"properties\"] = Object.assign(\n    { _gpxType: \"trk\" },\n    extractProperties(node),\n    getLineStyle(get1(node, \"extensions\")),\n    times.length\n      ? {\n          coordinateProperties: {\n            times: multi ? times : times[0],\n          },\n        }\n      : {}\n  );\n\n  for (const line of extractedLines) {\n    track.push(line.line);\n    if (!properties.coordinateProperties) {\n      properties.coordinateProperties = {};\n    }\n    const props = properties.coordinateProperties;\n    const entries = Object.entries(line.extendedValues);\n    for (let i = 0; i < entries.length; i++) {\n      const [name, val] = entries[i];\n      if (multi) {\n        if (!props[name]) {\n          props[name] = extractedLines.map((line) =>\n            new Array(line.line.length).fill(null)\n          );\n        }\n        props[name][i] = val;\n      } else {\n        props[name] = val;\n      }\n    }\n  }\n\n  return {\n    type: \"Feature\",\n    properties: properties,\n    geometry: multi\n      ? {\n          type: \"MultiLineString\",\n          coordinates: track,\n        }\n      : {\n          type: \"LineString\",\n          coordinates: track[0],\n        },\n  };\n}\n\n/**\n * Extract a point, if possible, from a given node,\n * which is usually a wpt or trkpt\n */\nfunction getPoint(node: Element): Feature<Point> | null {\n  const properties: Feature[\"properties\"] = Object.assign(\n    extractProperties(node),\n    getMulti(node, [\"sym\"])\n  );\n  const pair = coordPair(node);\n  if (!pair) return null;\n  return {\n    type: \"Feature\",\n    properties,\n    geometry: {\n      type: \"Point\",\n      coordinates: pair.coordinates,\n    },\n  };\n}\n\n/**\n * Convert GPX to GeoJSON incrementally, returning\n * a [Generator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators)\n * that yields output feature by feature.\n */\nexport function* gpxGen(node: Document): Generator<Feature> {\n  for (const track of $(node, \"trk\")) {\n    const feature = getTrack(track);\n    if (feature) yield feature;\n  }\n\n  for (const route of $(node, \"rte\")) {\n    const feature = getRoute(route);\n    if (feature) yield feature;\n  }\n\n  for (const waypoint of $(node, \"wpt\")) {\n    const point = getPoint(waypoint);\n    if (point) yield point;\n  }\n}\n\n/**\n *\n * Convert a GPX document to GeoJSON. The first argument, `doc`, must be a GPX\n * document as an XML DOM - not as a string. You can get this using jQuery's default\n * `.ajax` function or using a bare XMLHttpRequest with the `.response` property\n * holding an XML DOM.\n *\n * The output is a JavaScript object of GeoJSON data, same as `.kml` outputs, with the\n * addition of a `_gpxType` property on each `LineString` feature that indicates whether\n * the feature was encoded as a route (`rte`) or track (`trk`) in the GPX document.\n */\nexport function gpx(node: Document): FeatureCollection {\n  return {\n    type: \"FeatureCollection\",\n    features: Array.from(gpxGen(node)),\n  };\n}\n", "import { Feature, FeatureCollection, Position } from \"geojson\";\nimport { P, $, get, num1, nodeVal, get1 } from \"./shared\";\n\ntype PropertyMapping = readonly [string, string][];\n\nconst EXTENSIONS_NS = \"http://www.garmin.com/xmlschemas/ActivityExtension/v2\";\n\nconst TRACKPOINT_ATTRIBUTES: PropertyMapping = [\n  [\"heartRate\", \"heartRates\"],\n  [\"Cadence\", \"cadences\"],\n  // Extended Trackpoint attributes\n  [\"Speed\", \"speeds\"],\n  [\"Watts\", \"watts\"],\n];\n\nconst LAP_ATTRIBUTES: PropertyMapping = [\n  [\"TotalTimeSeconds\", \"totalTimeSeconds\"],\n  [\"DistanceMeters\", \"distanceMeters\"],\n  [\"MaximumSpeed\", \"maxSpeed\"],\n  [\"AverageHeartRateBpm\", \"avgHeartRate\"],\n  [\"MaximumHeartRateBpm\", \"maxHeartRate\"],\n\n  // Extended Lap attributes\n  [\"AvgSpeed\", \"avgSpeed\"],\n  [\"AvgWatts\", \"avgWatts\"],\n  [\"MaxWatts\", \"maxWatts\"],\n];\n\nfunction getProperties(node: Element, attributeNames: PropertyMapping) {\n  const properties = [];\n\n  for (const [tag, alias] of attributeNames) {\n    let elem = get1(node, tag);\n    if (!elem) {\n      const elements = node.getElementsByTagNameNS(EXTENSIONS_NS, tag);\n      if (elements.length) {\n        elem = elements[0];\n      }\n    }\n    const val = parseFloat(nodeVal(elem));\n    if (!isNaN(val)) {\n      properties.push([alias, val]);\n    }\n  }\n\n  return properties;\n}\n\nfunction coordPair(node: Element) {\n  const ll = [num1(node, \"LongitudeDegrees\"), num1(node, \"LatitudeDegrees\")];\n  if (\n    ll[0] === undefined ||\n    isNaN(ll[0]) ||\n    ll[1] === undefined ||\n    isNaN(ll[1])\n  ) {\n    return null;\n  }\n  const heartRate = get1(node, \"HeartRateBpm\");\n  const time = nodeVal(get1(node, \"Time\"));\n  get1(node, \"AltitudeMeters\", (alt) => {\n    const a = parseFloat(nodeVal(alt));\n    if (!isNaN(a)) {\n      ll.push(a);\n    }\n  });\n  return {\n    coordinates: ll as number[],\n    time: time || null,\n    heartRate: heartRate ? parseFloat(nodeVal(heartRate)) : null,\n    extensions: getProperties(node, TRACKPOINT_ATTRIBUTES),\n  };\n}\n\nfunction getPoints(node: Element) {\n  const pts = $(node, \"Trackpoint\");\n  const line: Position[] = [];\n  const times = [];\n  const heartRates = [];\n  if (pts.length < 2) return null; // Invalid line in GeoJSON\n  const extendedProperties: P = {};\n  const result = { extendedProperties };\n  for (let i = 0; i < pts.length; i++) {\n    const c = coordPair(pts[i]);\n    if (c === null) continue;\n    line.push(c.coordinates);\n    const { time, heartRate, extensions } = c;\n    if (time) times.push(time);\n    if (heartRate) heartRates.push(heartRate);\n    for (const [alias, value] of extensions) {\n      if (!extendedProperties[alias]) {\n        extendedProperties[alias] = Array(pts.length).fill(null);\n      }\n      extendedProperties[alias][i] = value;\n    }\n  }\n  if (line.length < 2) return null;\n  return Object.assign(result, {\n    line: line,\n    times: times,\n    heartRates: heartRates,\n  });\n}\n\nfunction getLap(node: Element): Feature | null {\n  const segments = $(node, \"Track\");\n  const track = [];\n  const times = [];\n  const heartRates = [];\n  const allExtendedProperties = [];\n  let line;\n  const properties: P = Object.assign(\n    Object.fromEntries(getProperties(node, LAP_ATTRIBUTES)),\n    get(node, \"Name\", (nameElement) => {\n      return { name: nodeVal(nameElement) };\n    })\n  );\n\n  for (const segment of segments) {\n    line = getPoints(segment);\n    if (line) {\n      track.push(line.line);\n      if (line.times.length) times.push(line.times);\n      if (line.heartRates.length) heartRates.push(line.heartRates);\n      allExtendedProperties.push(line.extendedProperties);\n    }\n  }\n  for (let i = 0; i < allExtendedProperties.length; i++) {\n    const extendedProperties = allExtendedProperties[i];\n    for (const property in extendedProperties) {\n      if (segments.length === 1) {\n        if (line) {\n          properties[property] = line.extendedProperties[property];\n        }\n      } else {\n        if (!properties[property]) {\n          properties[property] = track.map((track) =>\n            Array(track.length).fill(null)\n          );\n        }\n        properties[property][i] = extendedProperties[property];\n      }\n    }\n  }\n\n  if (track.length === 0) return null;\n\n  if (times.length || heartRates.length) {\n    properties.coordinateProperties = Object.assign(\n      times.length\n        ? {\n            times: track.length === 1 ? times[0] : times,\n          }\n        : {},\n      heartRates.length\n        ? {\n            heart: track.length === 1 ? heartRates[0] : heartRates,\n          }\n        : {}\n    );\n  }\n\n  return {\n    type: \"Feature\",\n    properties: properties,\n    geometry:\n      track.length === 1\n        ? {\n            type: \"LineString\",\n            coordinates: track[0],\n          }\n        : {\n            type: \"MultiLineString\",\n            coordinates: track,\n          },\n  };\n}\n\n/**\n * Incrementally convert a TCX document to GeoJSON. The\n * first argument, `doc`, must be a TCX\n * document as an XML DOM - not as a string.\n */\nexport function* tcxGen(node: Document): Generator<Feature> {\n  for (const lap of $(node, \"Lap\")) {\n    const feature = getLap(lap);\n    if (feature) yield feature;\n  }\n\n  for (const course of $(node, \"Courses\")) {\n    const feature = getLap(course);\n    if (feature) yield feature;\n  }\n}\n\n/**\n * Convert a TCX document to GeoJSON. The first argument, `doc`, must be a TCX\n * document as an XML DOM - not as a string.\n */\nexport function tcx(node: Document): FeatureCollection {\n  return {\n    type: \"FeatureCollection\",\n    features: Array.from(tcxGen(node)),\n  };\n}\n", "import { P } from \"../shared\";\n\nexport function fixColor(v: string, prefix: string): P {\n  const properties: P = {};\n  const colorProp =\n    prefix == \"stroke\" || prefix === \"fill\" ? prefix : prefix + \"-color\";\n  if (v[0] === \"#\") {\n    v = v.substring(1);\n  }\n  if (v.length === 6 || v.length === 3) {\n    properties[colorProp] = \"#\" + v;\n  } else if (v.length === 8) {\n    properties[prefix + \"-opacity\"] = parseInt(v.substring(0, 2), 16) / 255;\n    properties[colorProp] =\n      \"#\" + v.substring(6, 8) + v.substring(4, 6) + v.substring(2, 4);\n  }\n  return properties;\n}\n", "import { P, get, num1, nodeVal, val1 } from \"../shared\";\nimport { fixColor } from \"./fixColor\";\n\nfunction numericProperty(node: Element, source: string, target: string): P {\n  const properties: P = {};\n  num1(node, source, (val) => {\n    properties[target] = val;\n  });\n  return properties;\n}\n\nfunction getColor(node: Element, output: string): P {\n  return get(node, \"color\", (elem) => fixColor(nodeVal(elem), output));\n}\n\nexport function extractIconHref(node: Element) {\n  return get(node, \"Icon\", (icon, properties) => {\n    val1(icon, \"href\", (href) => {\n      properties.icon = href;\n    });\n    return properties;\n  });\n}\n\nexport function extractIcon(node: Element) {\n  return get(node, \"IconStyle\", (iconStyle) => {\n    return Object.assign(\n      getColor(iconStyle, \"icon\"),\n      numericProperty(iconStyle, \"scale\", \"icon-scale\"),\n      numericProperty(iconStyle, \"heading\", \"icon-heading\"),\n      get(iconStyle, \"hotSpot\", (hotspot) => {\n        const left = parseFloat(hotspot.getAttribute(\"x\") || \"\");\n        const top = parseFloat(hotspot.getAttribute(\"y\") || \"\");\n        const xunits = hotspot.getAttribute(\"xunits\") || \"\";\n        const yunits = hotspot.getAttribute(\"yunits\") || \"\";\n        if (!isNaN(left) && !isNaN(top))\n          return {\n            \"icon-offset\": [left, top],\n            \"icon-offset-units\": [xunits, yunits],\n          };\n        return {};\n      }),\n      extractIconHref(iconStyle)\n    );\n  });\n}\n\nexport function extractLabel(node: Element) {\n  return get(node, \"LabelStyle\", (labelStyle) => {\n    return Object.assign(\n      getColor(labelStyle, \"label\"),\n      numericProperty(labelStyle, \"scale\", \"label-scale\")\n    );\n  });\n}\n\nexport function extractLine(node: Element) {\n  return get(node, \"LineStyle\", (lineStyle) => {\n    return Object.assign(\n      getColor(lineStyle, \"stroke\"),\n      numericProperty(lineStyle, \"width\", \"stroke-width\")\n    );\n  });\n}\n\nexport function extractPoly(node: Element) {\n  return get(node, \"PolyStyle\", (polyStyle, properties) => {\n    return Object.assign(\n      properties,\n      get(polyStyle, \"color\", (elem) => fixColor(nodeVal(elem), \"fill\")),\n      val1(polyStyle, \"fill\", (fill) => {\n        if (fill === \"0\") return { \"fill-opacity\": 0 };\n      }),\n      val1(polyStyle, \"outline\", (outline) => {\n        if (outline === \"0\") return { \"stroke-opacity\": 0 };\n      })\n    );\n  });\n}\n\nexport function extractStyle(node: Element) {\n  return Object.assign(\n    {},\n    extractPoly(node),\n    extractLine(node),\n    extractLabel(node),\n    extractIcon(node)\n  );\n}\n", "import {\n  get,\n  get1,\n  nodeVal,\n  $,\n  normalizeId,\n  P,\n  StyleMap,\n  val1,\n} from \"../shared\";\n\nexport type TypeConverter = (x: string) => unknown;\nexport type Schema = { [key: string]: TypeConverter };\n\nconst toNumber: TypeConverter = (x) => Number(x);\nexport const typeConverters: Record<string, TypeConverter> = {\n  string: (x) => x,\n  int: toNumber,\n  uint: toNumber,\n  short: toNumber,\n  ushort: toNumber,\n  float: toNumber,\n  double: toNumber,\n  bool: (x) => Boolean(x),\n};\n\nexport function extractExtendedData(node: Element, schema: Schema) {\n  return get(node, \"ExtendedData\", (extendedData, properties) => {\n    for (const data of $(extendedData, \"Data\")) {\n      properties[data.getAttribute(\"name\") || \"\"] = nodeVal(\n        get1(data, \"value\")\n      );\n    }\n    for (const simpleData of $(extendedData, \"SimpleData\")) {\n      const name = simpleData.getAttribute(\"name\") || \"\";\n      const typeConverter = schema[name] || typeConverters.string;\n      properties[name] = typeConverter(nodeVal(simpleData));\n    }\n    return properties;\n  });\n}\n\nexport function getMaybeHTMLDescription(node: Element) {\n  const descriptionNode = get1(node, \"description\");\n  for (const c of Array.from(descriptionNode?.childNodes || [])) {\n    if (c.nodeType === 4) {\n      return {\n        description: {\n          \"@type\": \"html\",\n          value: nodeVal(c as Element),\n        },\n      };\n    }\n  }\n  return {};\n}\n\nexport function extractTimeSpan(node: Element): P {\n  return get(node, \"TimeSpan\", (timeSpan) => {\n    return {\n      timespan: {\n        begin: nodeVal(get1(timeSpan, \"begin\")),\n        end: nodeVal(get1(timeSpan, \"end\")),\n      },\n    };\n  });\n}\n\nexport function extractTimeStamp(node: Element): P {\n  return get(node, \"TimeStamp\", (timeStamp) => {\n    return { timestamp: nodeVal(get1(timeStamp, \"when\")) };\n  });\n}\n\nexport function extractCascadedStyle(node: Element, styleMap: StyleMap): P {\n  return val1(node, \"styleUrl\", (styleUrl) => {\n    styleUrl = normalizeId(styleUrl);\n    if (styleMap[styleUrl]) {\n      return Object.assign({ styleUrl }, styleMap[styleUrl]);\n    }\n    // For backward-compatibility. Should we still include\n    // styleUrl even if it's not resolved?\n    return { styleUrl };\n  });\n}\n", "import { Position, Point, LineString, Geometry } from \"geojson\";\nimport { $, $ns, nodeVal, get1, isElement } from \"../shared\";\n\nconst removeSpace = /\\s*/g;\nconst trimSpace = /^\\s*|\\s*$/g;\nconst splitSpace = /\\s+/;\n\n/**\n * Get one coordinate from a coordinate array, if any\n */\nexport function coord1(value: string): Position {\n  return value\n    .replace(removeSpace, \"\")\n    .split(\",\")\n    .map(parseFloat)\n    .filter((num) => !isNaN(num))\n    .slice(0, 3);\n}\n\n/**\n * Get all coordinates from a coordinate array as [[],[]]\n */\nexport function coord(value: string): Position[] {\n  return value\n    .replace(trimSpace, \"\")\n    .split(splitSpace)\n    .map(coord1)\n    .filter((coord) => {\n      return coord.length >= 2;\n    });\n}\n\nfunction gxCoords(\n  node: Element\n): { geometry: Point | LineString; times: string[] } | null {\n  let elems = $(node, \"coord\");\n  if (elems.length === 0) {\n    elems = $ns(node, \"coord\", \"*\");\n  }\n\n  const coordinates = elems.map((elem) => {\n    return nodeVal(elem).split(\" \").map(parseFloat);\n  });\n\n  if (coordinates.length === 0) {\n    return null;\n  }\n\n  return {\n    geometry:\n      coordinates.length > 2\n        ? {\n            type: \"LineString\",\n            coordinates,\n          }\n        : {\n            type: \"Point\",\n            coordinates: coordinates[0],\n          },\n    times: $(node, \"when\").map((elem) => nodeVal(elem)),\n  };\n}\n\nexport function fixRing(ring: Position[]) {\n  if (ring.length === 0) return ring;\n  const first = ring[0];\n  const last = ring[ring.length - 1];\n  let equal = true;\n  for (let i = 0; i < Math.max(first.length, last.length); i++) {\n    if (first[i] !== last[i]) {\n      equal = false;\n      break;\n    }\n  }\n  if (!equal) {\n    return ring.concat([ring[0]]);\n  }\n  return ring;\n}\n\nexport function getCoordinates(node: Element) {\n  return nodeVal(get1(node, \"coordinates\"));\n}\n\ninterface GeometriesAndTimes {\n  geometries: Geometry[];\n  coordTimes: string[][];\n}\n\nexport function getGeometry(node: Element): GeometriesAndTimes {\n  let geometries: Geometry[] = [];\n  let coordTimes: string[][] = [];\n\n  for (let i = 0; i < node.childNodes.length; i++) {\n    const child = node.childNodes.item(i);\n    if (isElement(child)) {\n      switch (child.tagName) {\n        case \"MultiGeometry\":\n        case \"MultiTrack\":\n        case \"gx:MultiTrack\": {\n          const childGeometries = getGeometry(child);\n          geometries = geometries.concat(childGeometries.geometries);\n          coordTimes = coordTimes.concat(childGeometries.coordTimes);\n          break;\n        }\n\n        case \"Point\": {\n          const coordinates = coord1(getCoordinates(child));\n          if (coordinates.length >= 2) {\n            geometries.push({\n              type: \"Point\",\n              coordinates,\n            });\n          }\n          break;\n        }\n        case \"LinearRing\":\n        case \"LineString\": {\n          const coordinates = coord(getCoordinates(child));\n          if (coordinates.length >= 2) {\n            geometries.push({\n              type: \"LineString\",\n              coordinates,\n            });\n          }\n          break;\n        }\n        case \"Polygon\": {\n          const coords = [];\n          for (const linearRing of $(child, \"LinearRing\")) {\n            const ring = fixRing(coord(getCoordinates(linearRing)));\n            if (ring.length >= 4) {\n              coords.push(ring);\n            }\n          }\n          if (coords.length) {\n            geometries.push({\n              type: \"Polygon\",\n              coordinates: coords,\n            });\n          }\n          break;\n        }\n        case \"Track\":\n        case \"gx:Track\": {\n          const gx = gxCoords(child);\n          if (!gx) break;\n          const { times, geometry } = gx;\n          geometries.push(geometry);\n          if (times.length) coordTimes.push(times);\n          break;\n        }\n      }\n    }\n  }\n\n  return {\n    geometries,\n    coordTimes,\n  };\n}\n", "import { Feature, Geometry } from \"geojson\";\nimport { StyleMap, getMulti } from \"../shared\";\nimport {\n  extractCascadedStyle,\n  extractExtendedData,\n  extractTimeSpan,\n  extractTimeStamp,\n  getMaybeHTMLDescription,\n  Schema,\n} from \"./shared\";\nimport { extractStyle } from \"./extractStyle\";\nimport { getGeometry } from \"./geometry\";\nimport { KMLOptions } from \"lib/kml\";\n\nfunction geometryListToGeometry(geometries: Geometry[]): Geometry | null {\n  return geometries.length === 0\n    ? null\n    : geometries.length === 1\n    ? geometries[0]\n    : {\n        type: \"GeometryCollection\",\n        geometries,\n      };\n}\n\nexport function getPlacemark(\n  node: Element,\n  styleMap: StyleMap,\n  schema: Schema,\n  options: KMLOptions\n): Feature<Geometry | null> | null {\n  const { coordTimes, geometries } = getGeometry(node);\n\n  const geometry = geometryListToGeometry(geometries);\n\n  if (!geometry && options.skipNullGeometry) {\n    return null;\n  }\n\n  const feature: Feature<Geometry | null> = {\n    type: \"Feature\",\n    geometry,\n    properties: Object.assign(\n      getMulti(node, [\n        \"name\",\n        \"address\",\n        \"visibility\",\n        \"open\",\n        \"phoneNumber\",\n        \"description\",\n      ]),\n      getMaybeHTMLDescription(node),\n      extractCascadedStyle(node, styleMap),\n      extractStyle(node),\n      extractExtendedData(node, schema),\n      extractTimeSpan(node),\n      extractTimeStamp(node),\n      coordTimes.length\n        ? {\n            coordinateProperties: {\n              times: coordTimes.length === 1 ? coordTimes[0] : coordTimes,\n            },\n          }\n        : {}\n    ),\n  };\n\n  if (feature.properties?.visibility !== undefined) {\n    feature.properties.visibility = feature.properties.visibility !== \"0\";\n  }\n\n  const id = node.getAttribute(\"id\");\n  if (id !== null && id !== \"\") feature.id = id;\n  return feature;\n}\n", "import { Feature, Polygon } from \"geojson\";\nimport { StyleMap, get1, num1, getMulti } from \"../shared\";\nimport {\n  extractCascadedStyle,\n  extractExtendedData,\n  extractTimeSpan,\n  extractTimeStamp,\n  getMaybeHTMLDescription,\n  Schema,\n} from \"./shared\";\nimport { extractIconHref, extractStyle } from \"./extractStyle\";\nimport { coord, fixRing, getCoordinates } from \"./geometry\";\nimport { KMLOptions } from \"lib/kml\";\n\ninterface BoxGeometry {\n  bbox?: BBox;\n  geometry: Polygon;\n}\n\nfunction getGroundOverlayBox(node: Element): BoxGeometry | null {\n  const latLonQuad = get1(node, \"gx:LatLonQuad\");\n\n  if (latLonQuad) {\n    const ring = fixRing(coord(getCoordinates(node)));\n    return {\n      geometry: {\n        type: \"Polygon\",\n        coordinates: [ring],\n      },\n    };\n  }\n\n  return getLatLonBox(node);\n}\n\ntype BBox = [number, number, number, number];\n\nconst DEGREES_TO_RADIANS = Math.PI / 180;\n\nfunction rotateBox(\n  bbox: BBox,\n  coordinates: Polygon[\"coordinates\"],\n  rotation: number\n): Polygon[\"coordinates\"] {\n  const center = [(bbox[0] + bbox[2]) / 2, (bbox[1] + bbox[3]) / 2];\n\n  return [\n    coordinates[0].map((coordinate) => {\n      const dy = coordinate[1] - center[1];\n      const dx = coordinate[0] - center[0];\n      const distance = Math.sqrt(Math.pow(dy, 2) + Math.pow(dx, 2));\n      const angle = Math.atan2(dy, dx) + rotation * DEGREES_TO_RADIANS;\n\n      return [\n        center[0] + Math.cos(angle) * distance,\n        center[1] + Math.sin(angle) * distance,\n      ];\n    }),\n  ];\n}\n\nfunction getLatLonBox(node: Element): BoxGeometry | null {\n  const latLonBox = get1(node, \"LatLonBox\");\n\n  if (latLonBox) {\n    const north = num1(latLonBox, \"north\");\n    const west = num1(latLonBox, \"west\");\n    const east = num1(latLonBox, \"east\");\n    const south = num1(latLonBox, \"south\");\n    const rotation = num1(latLonBox, \"rotation\");\n\n    if (\n      typeof north === \"number\" &&\n      typeof south === \"number\" &&\n      typeof west === \"number\" &&\n      typeof east === \"number\"\n    ) {\n      const bbox: BBox = [west, south, east, north];\n      let coordinates = [\n        [\n          [west, north], // top left\n          [east, north], // top right\n          [east, south], // top right\n          [west, south], // bottom left\n          [west, north], // top left (again)\n        ],\n      ];\n      if (typeof rotation === \"number\") {\n        coordinates = rotateBox(bbox, coordinates, rotation);\n      }\n      return {\n        bbox,\n        geometry: {\n          type: \"Polygon\",\n          coordinates,\n        },\n      };\n    }\n  }\n\n  return null;\n}\n\nexport function getGroundOverlay(\n  node: Element,\n  styleMap: StyleMap,\n  schema: Schema,\n  options: KMLOptions\n): Feature<Polygon | null> | null {\n  const box = getGroundOverlayBox(node);\n\n  const geometry = box?.geometry || null;\n\n  if (!geometry && options.skipNullGeometry) {\n    return null;\n  }\n\n  const feature: Feature<Polygon | null> = {\n    type: \"Feature\",\n    geometry,\n    properties: Object.assign(\n      /**\n       * Related to\n       * https://gist.github.com/tmcw/037a1cb6660d74a392e9da7446540f46\n       */\n      { \"@geometry-type\": \"groundoverlay\" },\n      getMulti(node, [\n        \"name\",\n        \"address\",\n        \"visibility\",\n        \"open\",\n        \"phoneNumber\",\n        \"description\",\n      ]),\n      getMaybeHTMLDescription(node),\n      extractCascadedStyle(node, styleMap),\n      extractStyle(node),\n      extractIconHref(node),\n      extractExtendedData(node, schema),\n      extractTimeSpan(node),\n      extractTimeStamp(node)\n    ),\n  };\n\n  if (box?.bbox) {\n    feature.bbox = box.bbox;\n  }\n\n  if (feature.properties?.visibility !== undefined) {\n    feature.properties.visibility = feature.properties.visibility !== \"0\";\n  }\n\n  const id = node.getAttribute(\"id\");\n  if (id !== null && id !== \"\") feature.id = id;\n  return feature;\n}\n", "import { extractStyle } from \"./kml/extractStyle\";\nimport { getPlacemark } from \"./kml/placemark\";\nimport { getGroundOverlay } from \"./kml/ground_overlay\";\nimport { FeatureCollection, Geometry } from \"geojson\";\nimport {\n  $,\n  StyleMap,\n  P,\n  F,\n  val1,\n  nodeVal,\n  isElement,\n  normalizeId,\n} from \"./shared\";\nimport { Schema, typeConverters } from \"./kml/shared\";\n\n/**\n * Options to customize KML output.\n *\n * The only option currently\n * is `skipNullGeometry`. Both the KML and GeoJSON formats support\n * the idea of features that don't have geometries: in KML,\n * this is a Placemark without a Point, etc element, and in GeoJSON\n * it's a geometry member with a value of `null`.\n *\n * toGeoJSON, by default, translates null geometries in KML to\n * null geometries in GeoJSON. For systems that use GeoJSON but\n * don't support null geometries, you can specify `skipNullGeometry`\n * to omit these features entirely and only include\n * features that have a geometry defined.\n */\nexport interface KMLOptions {\n  skipNullGeometry?: boolean;\n}\n\n/**\n * A folder including metadata. Folders\n * may contain other folders or features,\n * or nothing at all.\n */\nexport interface Folder {\n  type: \"folder\";\n  /**\n   * Standard values:\n   *\n   * * \"name\",\n   * * \"visibility\",\n   * * \"open\",\n   * * \"address\",\n   * * \"description\",\n   * * \"phoneNumber\",\n   * * \"visibility\",\n   */\n  meta: {\n    [key: string]: unknown;\n  };\n  children: Array<Folder | F>;\n}\n\n/**\n * A nested folder structure, represented\n * as a tree with folders and features.\n */\nexport interface Root {\n  type: \"root\";\n  children: Array<Folder | F>;\n}\n\ntype TreeContainer = Root | Folder;\n\nfunction getStyleId(style: Element) {\n  let id = style.getAttribute(\"id\");\n  const parentNode = style.parentNode;\n  if (\n    !id &&\n    isElement(parentNode) &&\n    parentNode.localName === \"CascadingStyle\"\n  ) {\n    id = parentNode.getAttribute(\"kml:id\") || parentNode.getAttribute(\"id\");\n  }\n  return normalizeId(id || \"\");\n}\n\nfunction buildStyleMap(node: Document): StyleMap {\n  const styleMap: StyleMap = {};\n  for (const style of $(node, \"Style\")) {\n    styleMap[getStyleId(style)] = extractStyle(style);\n  }\n  for (const map of $(node, \"StyleMap\")) {\n    const id = normalizeId(map.getAttribute(\"id\") || \"\");\n    val1(map, \"styleUrl\", (styleUrl) => {\n      styleUrl = normalizeId(styleUrl);\n      if (styleMap[styleUrl]) {\n        styleMap[id] = styleMap[styleUrl];\n      }\n    });\n  }\n  return styleMap;\n}\n\nfunction buildSchema(node: Document): Schema {\n  const schema: Schema = {};\n  for (const field of $(node, \"SimpleField\")) {\n    schema[field.getAttribute(\"name\") || \"\"] =\n      typeConverters[field.getAttribute(\"type\") || \"\"] ||\n      typeConverters[\"string\"];\n  }\n  return schema;\n}\n\nconst FOLDER_PROPS = [\n  \"name\",\n  \"visibility\",\n  \"open\",\n  \"address\",\n  \"description\",\n  \"phoneNumber\",\n  \"visibility\",\n] as const;\n\nfunction getFolder(node: Element): Folder {\n  const meta: P = {};\n\n  for (const child of Array.from(node.childNodes)) {\n    if (isElement(child) && FOLDER_PROPS.includes(child.tagName as any)) {\n      meta[child.tagName] = nodeVal(child);\n    }\n  }\n\n  return {\n    type: \"folder\",\n    meta,\n    children: [],\n  };\n}\n\n/**\n * Yield a nested tree with KML folder structure\n *\n * This generates a tree with the given structure:\n *\n * ```js\n * {\n *   \"type\": \"root\",\n *   \"children\": [\n *     {\n *       \"type\": \"folder\",\n *       \"meta\": {\n *         \"name\": \"Test\"\n *       },\n *       \"children\": [\n *          // ...features and folders\n *       ]\n *     }\n *     // ...features\n *   ]\n * }\n * ```\n *\n * ### GroundOverlay\n *\n * GroundOverlay elements are converted into\n * `Feature` objects with `Polygon` geometries,\n * a property like:\n *\n * ```json\n * {\n *   \"@geometry-type\": \"groundoverlay\"\n * }\n * ```\n *\n * And the ground overlay's image URL in the `href`\n * property. Ground overlays will need to be displayed\n * with a separate method to other features, depending\n * on which map framework you're using.\n */\nexport function kmlWithFolders(\n  node: Document,\n  options: KMLOptions = {\n    skipNullGeometry: false,\n  }\n): Root {\n  const styleMap = buildStyleMap(node);\n  const schema = buildSchema(node);\n\n  // atomic geospatial types supported by KML - MultiGeometry is\n  // handled separately\n  // all root placemarks in the file\n  const placemarks = [];\n  const tree: Root = { type: \"root\", children: [] };\n\n  function traverse(\n    node: Document | ChildNode | Element,\n    pointer: TreeContainer,\n    options: KMLOptions\n  ) {\n    if (isElement(node)) {\n      switch (node.tagName) {\n        case \"GroundOverlay\": {\n          placemarks.push(node);\n          const placemark = getGroundOverlay(node, styleMap, schema, options);\n          if (placemark) {\n            pointer.children.push(placemark);\n          }\n          break;\n        }\n        case \"Placemark\": {\n          placemarks.push(node);\n          const placemark = getPlacemark(node, styleMap, schema, options);\n          if (placemark) {\n            pointer.children.push(placemark);\n          }\n          break;\n        }\n        case \"Folder\": {\n          const folder = getFolder(node);\n          pointer.children.push(folder);\n          pointer = folder;\n          break;\n        }\n      }\n    }\n\n    if (node.childNodes) {\n      for (let i = 0; i < node.childNodes.length; i++) {\n        traverse(node.childNodes[i], pointer, options);\n      }\n    }\n  }\n\n  traverse(node, tree, options);\n\n  return tree;\n}\n\n/**\n * Convert KML to GeoJSON incrementally, returning\n * a [Generator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators)\n * that yields output feature by feature.\n */\nexport function* kmlGen(\n  node: Document,\n  options: KMLOptions = {\n    skipNullGeometry: false,\n  }\n): Generator<F> {\n  const styleMap = buildStyleMap(node);\n  const schema = buildSchema(node);\n  for (const placemark of $(node, \"Placemark\")) {\n    const feature = getPlacemark(placemark, styleMap, schema, options);\n    if (feature) yield feature;\n  }\n  for (const groundOverlay of $(node, \"GroundOverlay\")) {\n    const feature = getGroundOverlay(groundOverlay, styleMap, schema, options);\n    if (feature) yield feature;\n  }\n}\n\n/**\n * Convert a KML document to GeoJSON. The first argument, `doc`, must be a KML\n * document as an XML DOM - not as a string. You can get this using jQuery's default\n * `.ajax` function or using a bare XMLHttpRequest with the `.response` property\n * holding an XML DOM.\n *\n * The output is a JavaScript object of GeoJSON data. You can convert it to a string\n * with [JSON.stringify](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify)\n * or use it directly in libraries.\n */\nexport function kml(\n  node: Document,\n  options: KMLOptions = {\n    skipNullGeometry: false,\n  }\n): FeatureCollection<Geometry | null> {\n  return {\n    type: \"FeatureCollection\",\n    features: Array.from(kmlGen(node, options)),\n  };\n}\n"],
  "mappings": "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",
  "names": ["coordPair", "getPoints", "line", "track", "coord", "node", "options"]
}
