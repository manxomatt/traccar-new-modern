{
  "version": 3,
  "sources": ["../../@base2/pretty-print-object/src/index.ts", "../../react-element-to-jsx-string/node_modules/react-is/cjs/react-is.development.js", "../../react-element-to-jsx-string/node_modules/react-is/index.js", "../../react-element-to-jsx-string/node_modules/is-plain-object/dist/is-plain-object.mjs", "../../react-element-to-jsx-string/src/formatter/spacer.js", "../../react-element-to-jsx-string/src/formatter/sortObject.js", "../../react-element-to-jsx-string/src/tree.js", "../../react-element-to-jsx-string/src/parser/parseReactElement.js", "../../react-element-to-jsx-string/src/formatter/formatFunction.js", "../../react-element-to-jsx-string/src/formatter/formatComplexDataStructure.js", "../../react-element-to-jsx-string/src/formatter/formatPropValue.js", "../../react-element-to-jsx-string/src/formatter/formatProp.js", "../../react-element-to-jsx-string/src/formatter/mergeSiblingPlainStringChildrenReducer.js", "../../react-element-to-jsx-string/src/formatter/sortPropsByNames.js", "../../react-element-to-jsx-string/src/formatter/createPropFilter.js", "../../react-element-to-jsx-string/src/formatter/formatReactElementNode.js", "../../react-element-to-jsx-string/src/formatter/formatReactFragmentNode.js", "../../react-element-to-jsx-string/src/formatter/formatTreeNode.js", "../../react-element-to-jsx-string/src/formatter/formatTree.js", "../../react-element-to-jsx-string/src/index.js"],
  "sourcesContent": [null, "/**\n * @license React\n * react-is.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n'use strict';\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n\n// ATTENTION\n\nvar REACT_ELEMENT_TYPE =  Symbol.for('react.element');\nvar REACT_PORTAL_TYPE =  Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE =  Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE =  Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE =  Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE =  Symbol.for('react.provider');\nvar REACT_CONTEXT_TYPE =  Symbol.for('react.context');\nvar REACT_SERVER_CONTEXT_TYPE =  Symbol.for('react.server_context');\nvar REACT_FORWARD_REF_TYPE =  Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE =  Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE =  Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE =  Symbol.for('react.memo');\nvar REACT_LAZY_TYPE =  Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE =  Symbol.for('react.offscreen');\n\nvar REACT_MODULE_REFERENCE;\n\n{\n  REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');\n}\n\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction typeOf(object) {\n  if (typeof object === 'object' && object !== null) {\n    var $$typeof = object.$$typeof;\n\n    switch ($$typeof) {\n      case REACT_ELEMENT_TYPE:\n        var type = object.type;\n\n        switch (type) {\n          case REACT_FRAGMENT_TYPE:\n          case REACT_PROFILER_TYPE:\n          case REACT_STRICT_MODE_TYPE:\n          case REACT_SUSPENSE_TYPE:\n          case REACT_SUSPENSE_LIST_TYPE:\n            return type;\n\n          default:\n            var $$typeofType = type && type.$$typeof;\n\n            switch ($$typeofType) {\n              case REACT_SERVER_CONTEXT_TYPE:\n              case REACT_CONTEXT_TYPE:\n              case REACT_FORWARD_REF_TYPE:\n              case REACT_LAZY_TYPE:\n              case REACT_MEMO_TYPE:\n              case REACT_PROVIDER_TYPE:\n                return $$typeofType;\n\n              default:\n                return $$typeof;\n            }\n\n        }\n\n      case REACT_PORTAL_TYPE:\n        return $$typeof;\n    }\n  }\n\n  return undefined;\n}\nvar ContextConsumer = REACT_CONTEXT_TYPE;\nvar ContextProvider = REACT_PROVIDER_TYPE;\nvar Element = REACT_ELEMENT_TYPE;\nvar ForwardRef = REACT_FORWARD_REF_TYPE;\nvar Fragment = REACT_FRAGMENT_TYPE;\nvar Lazy = REACT_LAZY_TYPE;\nvar Memo = REACT_MEMO_TYPE;\nvar Portal = REACT_PORTAL_TYPE;\nvar Profiler = REACT_PROFILER_TYPE;\nvar StrictMode = REACT_STRICT_MODE_TYPE;\nvar Suspense = REACT_SUSPENSE_TYPE;\nvar SuspenseList = REACT_SUSPENSE_LIST_TYPE;\nvar hasWarnedAboutDeprecatedIsAsyncMode = false;\nvar hasWarnedAboutDeprecatedIsConcurrentMode = false; // AsyncMode should be deprecated\n\nfunction isAsyncMode(object) {\n  {\n    if (!hasWarnedAboutDeprecatedIsAsyncMode) {\n      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint\n\n      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 18+.');\n    }\n  }\n\n  return false;\n}\nfunction isConcurrentMode(object) {\n  {\n    if (!hasWarnedAboutDeprecatedIsConcurrentMode) {\n      hasWarnedAboutDeprecatedIsConcurrentMode = true; // Using console['warn'] to evade Babel and ESLint\n\n      console['warn']('The ReactIs.isConcurrentMode() alias has been deprecated, ' + 'and will be removed in React 18+.');\n    }\n  }\n\n  return false;\n}\nfunction isContextConsumer(object) {\n  return typeOf(object) === REACT_CONTEXT_TYPE;\n}\nfunction isContextProvider(object) {\n  return typeOf(object) === REACT_PROVIDER_TYPE;\n}\nfunction isElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\nfunction isForwardRef(object) {\n  return typeOf(object) === REACT_FORWARD_REF_TYPE;\n}\nfunction isFragment(object) {\n  return typeOf(object) === REACT_FRAGMENT_TYPE;\n}\nfunction isLazy(object) {\n  return typeOf(object) === REACT_LAZY_TYPE;\n}\nfunction isMemo(object) {\n  return typeOf(object) === REACT_MEMO_TYPE;\n}\nfunction isPortal(object) {\n  return typeOf(object) === REACT_PORTAL_TYPE;\n}\nfunction isProfiler(object) {\n  return typeOf(object) === REACT_PROFILER_TYPE;\n}\nfunction isStrictMode(object) {\n  return typeOf(object) === REACT_STRICT_MODE_TYPE;\n}\nfunction isSuspense(object) {\n  return typeOf(object) === REACT_SUSPENSE_TYPE;\n}\nfunction isSuspenseList(object) {\n  return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;\n}\n\nexports.ContextConsumer = ContextConsumer;\nexports.ContextProvider = ContextProvider;\nexports.Element = Element;\nexports.ForwardRef = ForwardRef;\nexports.Fragment = Fragment;\nexports.Lazy = Lazy;\nexports.Memo = Memo;\nexports.Portal = Portal;\nexports.Profiler = Profiler;\nexports.StrictMode = StrictMode;\nexports.Suspense = Suspense;\nexports.SuspenseList = SuspenseList;\nexports.isAsyncMode = isAsyncMode;\nexports.isConcurrentMode = isConcurrentMode;\nexports.isContextConsumer = isContextConsumer;\nexports.isContextProvider = isContextProvider;\nexports.isElement = isElement;\nexports.isForwardRef = isForwardRef;\nexports.isFragment = isFragment;\nexports.isLazy = isLazy;\nexports.isMemo = isMemo;\nexports.isPortal = isPortal;\nexports.isProfiler = isProfiler;\nexports.isStrictMode = isStrictMode;\nexports.isSuspense = isSuspense;\nexports.isSuspenseList = isSuspenseList;\nexports.isValidElementType = isValidElementType;\nexports.typeOf = typeOf;\n  })();\n}\n", "'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react-is.production.min.js');\n} else {\n  module.exports = require('./cjs/react-is.development.js');\n}\n", "/*!\n * is-plain-object <https://github.com/jonschlinkert/is-plain-object>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nfunction isObject(o) {\n  return Object.prototype.toString.call(o) === '[object Object]';\n}\n\nfunction isPlainObject(o) {\n  var ctor,prot;\n\n  if (isObject(o) === false) return false;\n\n  // If has modified constructor\n  ctor = o.constructor;\n  if (ctor === undefined) return true;\n\n  // If has modified prototype\n  prot = ctor.prototype;\n  if (isObject(prot) === false) return false;\n\n  // If constructor does not have an Object-specific method\n  if (prot.hasOwnProperty('isPrototypeOf') === false) {\n    return false;\n  }\n\n  // Most likely a plain Object\n  return true;\n}\n\nexport { isPlainObject };\n", "/* @flow */\n\nexport default (times: number, tabStop: number): string => {\n  if (times === 0) {\n    return '';\n  }\n\n  return new Array(times * tabStop).fill(' ').join('');\n};\n", "/* @flow */\nimport * as React from 'react';\n\nfunction safeSortObject(value: any, seen: WeakSet<any>): any {\n  // return non-object value as is\n  if (value === null || typeof value !== 'object') {\n    return value;\n  }\n\n  // return date, regexp and react element values as is\n  if (\n    value instanceof Date ||\n    value instanceof RegExp ||\n    React.isValidElement(value)\n  ) {\n    return value;\n  }\n\n  seen.add(value);\n\n  // make a copy of array with each item passed through the sorting algorithm\n  if (Array.isArray(value)) {\n    return value.map(v => safeSortObject(v, seen));\n  }\n\n  // make a copy of object with key sorted\n  return Object.keys(value)\n    .sort()\n    .reduce((result, key) => {\n      if (key === '_owner') {\n        return result;\n      }\n      if (key === 'current' || seen.has(value[key])) {\n        // eslint-disable-next-line no-param-reassign\n        result[key] = '[Circular]';\n      } else {\n        // eslint-disable-next-line no-param-reassign\n        result[key] = safeSortObject(value[key], seen);\n      }\n      return result;\n    }, {});\n}\n\nexport default function sortObject(value: any): any {\n  return safeSortObject(value, new WeakSet());\n}\n", "/* @flow */\n/* eslint-disable no-use-before-define */\n\nimport type { Key } from 'react';\n\ntype PropsType = { [key: string]: any };\ntype DefaultPropsType = { [key: string]: any };\n\nexport type StringTreeNode = {|\n  type: 'string',\n  value: string,\n|};\n\nexport type NumberTreeNode = {|\n  type: 'number',\n  value: number,\n|};\n\nexport type ReactElementTreeNode = {|\n  type: 'ReactElement',\n  displayName: string,\n  props: PropsType,\n  defaultProps: DefaultPropsType,\n  childrens: TreeNode[],\n|};\n\nexport type ReactFragmentTreeNode = {|\n  type: 'ReactFragment',\n  key: ?Key,\n  childrens: TreeNode[],\n|};\n\nexport type TreeNode =\n  | StringTreeNode\n  | NumberTreeNode\n  | ReactElementTreeNode\n  | ReactFragmentTreeNode;\n\nexport const createStringTreeNode = (value: string): StringTreeNode => ({\n  type: 'string',\n  value,\n});\n\nexport const createNumberTreeNode = (value: number): NumberTreeNode => ({\n  type: 'number',\n  value,\n});\n\nexport const createReactElementTreeNode = (\n  displayName: string,\n  props: PropsType,\n  defaultProps: DefaultPropsType,\n  childrens: TreeNode[]\n): ReactElementTreeNode => ({\n  type: 'ReactElement',\n  displayName,\n  props,\n  defaultProps,\n  childrens,\n});\n\nexport const createReactFragmentTreeNode = (\n  key: ?Key,\n  childrens: TreeNode[]\n): ReactFragmentTreeNode => ({\n  type: 'ReactFragment',\n  key,\n  childrens,\n});\n", "/* @flow */\n\nimport React, { type Element as ReactElement, Fragment } from 'react';\nimport {\n  ForwardRef,\n  isContextConsumer,\n  isContextProvider,\n  isForwardRef,\n  isLazy,\n  isMemo,\n  isProfiler,\n  isStrictMode,\n  isSuspense,\n  Memo,\n} from 'react-is';\nimport type { Options } from './../options';\nimport {\n  createStringTreeNode,\n  createNumberTreeNode,\n  createReactElementTreeNode,\n  createReactFragmentTreeNode,\n} from './../tree';\nimport type { TreeNode } from './../tree';\n\nconst supportFragment = Boolean(Fragment);\n\nconst getFunctionTypeName = (functionType): string => {\n  if (!functionType.name || functionType.name === '_default') {\n    return 'No Display Name';\n  }\n  return functionType.name;\n};\n\nconst getWrappedComponentDisplayName = (Component: *): string => {\n  switch (true) {\n    case Boolean(Component.displayName):\n      return Component.displayName;\n    case Component.$$typeof === Memo:\n      return getWrappedComponentDisplayName(Component.type);\n    case Component.$$typeof === ForwardRef:\n      return getWrappedComponentDisplayName(Component.render);\n    default:\n      return getFunctionTypeName(Component);\n  }\n};\n\n// heavily inspired by:\n// https://github.com/facebook/react/blob/3746eaf985dd92f8aa5f5658941d07b6b855e9d9/packages/react-devtools-shared/src/backend/renderer.js#L399-L496\nconst getReactElementDisplayName = (element: ReactElement<*>): string => {\n  switch (true) {\n    case typeof element.type === 'string':\n      return element.type;\n    case typeof element.type === 'function':\n      if (element.type.displayName) {\n        return element.type.displayName;\n      }\n      return getFunctionTypeName(element.type);\n    case isForwardRef(element):\n    case isMemo(element):\n      return getWrappedComponentDisplayName(element.type);\n    case isContextConsumer(element):\n      return `${element.type._context.displayName || 'Context'}.Consumer`;\n    case isContextProvider(element):\n      return `${element.type._context.displayName || 'Context'}.Provider`;\n    case isLazy(element):\n      return 'Lazy';\n    case isProfiler(element):\n      return 'Profiler';\n    case isStrictMode(element):\n      return 'StrictMode';\n    case isSuspense(element):\n      return 'Suspense';\n    default:\n      return 'UnknownElementType';\n  }\n};\n\nconst noChildren = (propsValue, propName) => propName !== 'children';\n\nconst onlyMeaningfulChildren = (children): boolean =>\n  children !== true &&\n  children !== false &&\n  children !== null &&\n  children !== '';\n\nconst filterProps = (originalProps: {}, cb: (any, string) => boolean) => {\n  const filteredProps = {};\n\n  Object.keys(originalProps)\n    .filter(key => cb(originalProps[key], key))\n    .forEach(key => (filteredProps[key] = originalProps[key]));\n\n  return filteredProps;\n};\n\nconst parseReactElement = (\n  element: ReactElement<*> | string | number,\n  options: Options\n): TreeNode => {\n  const { displayName: displayNameFn = getReactElementDisplayName } = options;\n\n  if (typeof element === 'string') {\n    return createStringTreeNode(element);\n  } else if (typeof element === 'number') {\n    return createNumberTreeNode(element);\n  } else if (!React.isValidElement(element)) {\n    throw new Error(\n      `react-element-to-jsx-string: Expected a React.Element, got \\`${typeof element}\\``\n    );\n  }\n\n  const displayName = displayNameFn(element);\n\n  const props = filterProps(element.props, noChildren);\n  if (element.ref !== null) {\n    props.ref = element.ref;\n  }\n\n  const key = element.key;\n  if (typeof key === 'string' && key.search(/^\\./)) {\n    // React automatically add key=\".X\" when there are some children\n    props.key = key;\n  }\n\n  const defaultProps = filterProps(element.type.defaultProps || {}, noChildren);\n  const childrens = React.Children.toArray(element.props.children)\n    .filter(onlyMeaningfulChildren)\n    .map(child => parseReactElement(child, options));\n\n  if (supportFragment && element.type === Fragment) {\n    return createReactFragmentTreeNode(key, childrens);\n  }\n\n  return createReactElementTreeNode(\n    displayName,\n    props,\n    defaultProps,\n    childrens\n  );\n};\n\nexport default parseReactElement;\n", "import type { Options } from './../options';\n\nfunction noRefCheck() {}\n\nexport const inlineFunction = (fn: any): string =>\n  fn\n    .toString()\n    .split('\\n')\n    .map(line => line.trim())\n    .join('');\n\nexport const preserveFunctionLineBreak = (fn: any): string => fn.toString();\n\nconst defaultFunctionValue = inlineFunction;\n\nexport default (fn: Function, options: Options): string => {\n  const { functionValue = defaultFunctionValue, showFunctions } = options;\n  if (!showFunctions && functionValue === defaultFunctionValue) {\n    return functionValue(noRefCheck);\n  }\n\n  return functionValue(fn);\n};\n", "/* @flow */\n\nimport { isValidElement } from 'react';\nimport { prettyPrint } from '@base2/pretty-print-object';\nimport sortObject from './sortObject';\nimport parseReactElement from './../parser/parseReactElement';\nimport formatTreeNode from './formatTreeNode';\nimport formatFunction from './formatFunction';\nimport spacer from './spacer';\nimport type { Options } from './../options';\n\nexport default (\n  value: Object | Array<any>,\n  inline: boolean,\n  lvl: number,\n  options: Options\n): string => {\n  const normalizedValue = sortObject(value);\n\n  const stringifiedValue = prettyPrint(normalizedValue, {\n    transform: (currentObj, prop, originalResult) => {\n      const currentValue = currentObj[prop];\n\n      if (currentValue && isValidElement(currentValue)) {\n        return formatTreeNode(\n          parseReactElement(currentValue, options),\n          true,\n          lvl,\n          options\n        );\n      }\n\n      if (typeof currentValue === 'function') {\n        return formatFunction(currentValue, options);\n      }\n\n      return originalResult;\n    },\n  });\n\n  if (inline) {\n    return stringifiedValue\n      .replace(/\\s+/g, ' ')\n      .replace(/{ /g, '{')\n      .replace(/ }/g, '}')\n      .replace(/\\[ /g, '[')\n      .replace(/ ]/g, ']');\n  }\n\n  // Replace tabs with spaces, and add necessary indentation in front of each new line\n  return stringifiedValue\n    .replace(/\\t/g, spacer(1, options.tabStop))\n    .replace(/\\n([^$])/g, `\\n${spacer(lvl + 1, options.tabStop)}$1`);\n};\n", "/* @flow */\n\nimport { isPlainObject } from 'is-plain-object';\nimport { isValidElement } from 'react';\nimport formatComplexDataStructure from './formatComplexDataStructure';\nimport formatFunction from './formatFunction';\nimport formatTreeNode from './formatTreeNode';\nimport type { Options } from './../options';\nimport parseReactElement from './../parser/parseReactElement';\n\nconst escape = (s: string): string => s.replace(/\"/g, '&quot;');\n\nconst formatPropValue = (\n  propValue: any,\n  inline: boolean,\n  lvl: number,\n  options: Options\n): string => {\n  if (typeof propValue === 'number') {\n    return `{${String(propValue)}}`;\n  }\n\n  if (typeof propValue === 'string') {\n    return `\"${escape(propValue)}\"`;\n  }\n\n  // > \"Symbols (new in ECMAScript 2015, not yet supported in Flow)\"\n  // @see: https://flow.org/en/docs/types/primitives/\n  // $FlowFixMe: Flow does not support Symbol\n  if (typeof propValue === 'symbol') {\n    const symbolDescription = propValue\n      .valueOf()\n      .toString()\n      .replace(/Symbol\\((.*)\\)/, '$1');\n\n    if (!symbolDescription) {\n      return `{Symbol()}`;\n    }\n\n    return `{Symbol('${symbolDescription}')}`;\n  }\n\n  if (typeof propValue === 'function') {\n    return `{${formatFunction(propValue, options)}}`;\n  }\n\n  if (isValidElement(propValue)) {\n    return `{${formatTreeNode(\n      parseReactElement(propValue, options),\n      true,\n      lvl,\n      options\n    )}}`;\n  }\n\n  if (propValue instanceof Date) {\n    if (isNaN(propValue.valueOf())) {\n      return `{new Date(NaN)}`;\n    }\n    return `{new Date(\"${propValue.toISOString()}\")}`;\n  }\n\n  if (isPlainObject(propValue) || Array.isArray(propValue)) {\n    return `{${formatComplexDataStructure(propValue, inline, lvl, options)}}`;\n  }\n\n  return `{${String(propValue)}}`;\n};\n\nexport default formatPropValue;\n", "/* @flow */\n\nimport spacer from './spacer';\nimport formatPropValue from './formatPropValue';\nimport type { Options } from './../options';\n\nexport default (\n  name: string,\n  hasValue: boolean,\n  value: any,\n  hasDefaultValue: boolean,\n  defaultValue: any,\n  inline: boolean,\n  lvl: number,\n  options: Options\n): {\n  attributeFormattedInline: string,\n  attributeFormattedMultiline: string,\n  isMultilineAttribute: boolean,\n} => {\n  if (!hasValue && !hasDefaultValue) {\n    throw new Error(\n      `The prop \"${name}\" has no value and no default: could not be formatted`\n    );\n  }\n\n  const usedValue = hasValue ? value : defaultValue;\n\n  const { useBooleanShorthandSyntax, tabStop } = options;\n\n  const formattedPropValue = formatPropValue(usedValue, inline, lvl, options);\n\n  let attributeFormattedInline = ' ';\n  let attributeFormattedMultiline = `\\n${spacer(lvl + 1, tabStop)}`;\n  const isMultilineAttribute = formattedPropValue.includes('\\n');\n\n  if (\n    useBooleanShorthandSyntax &&\n    formattedPropValue === '{false}' &&\n    !hasDefaultValue\n  ) {\n    // If a boolean is false and not different from it's default, we do not render the attribute\n    attributeFormattedInline = '';\n    attributeFormattedMultiline = '';\n  } else if (useBooleanShorthandSyntax && formattedPropValue === '{true}') {\n    attributeFormattedInline += `${name}`;\n    attributeFormattedMultiline += `${name}`;\n  } else {\n    attributeFormattedInline += `${name}=${formattedPropValue}`;\n    attributeFormattedMultiline += `${name}=${formattedPropValue}`;\n  }\n\n  return {\n    attributeFormattedInline,\n    attributeFormattedMultiline,\n    isMultilineAttribute,\n  };\n};\n", "/* @flow */\n\nimport { createStringTreeNode } from './../tree';\nimport type { TreeNode } from './../tree';\n\nexport default (\n  previousNodes: TreeNode[],\n  currentNode: TreeNode\n): TreeNode[] => {\n  const nodes = previousNodes.slice(\n    0,\n    previousNodes.length > 0 ? previousNodes.length - 1 : 0\n  );\n  const previousNode = previousNodes[previousNodes.length - 1];\n\n  if (\n    previousNode &&\n    (currentNode.type === 'string' || currentNode.type === 'number') &&\n    (previousNode.type === 'string' || previousNode.type === 'number')\n  ) {\n    nodes.push(\n      createStringTreeNode(\n        String(previousNode.value) + String(currentNode.value)\n      )\n    );\n  } else {\n    if (previousNode) {\n      nodes.push(previousNode);\n    }\n\n    nodes.push(currentNode);\n  }\n\n  return nodes;\n};\n", "/* @flow */\n\nconst isKeyOrRefProps = (propName: string) => ['key', 'ref'].includes(propName);\n\nexport default (shouldSortUserProps: boolean) => (\n  props: string[]\n): string[] => {\n  const haveKeyProp = props.includes('key');\n  const haveRefProp = props.includes('ref');\n\n  const userPropsOnly = props.filter(oneProp => !isKeyOrRefProps(oneProp));\n\n  const sortedProps = shouldSortUserProps\n    ? [...userPropsOnly.sort()] // We use basic lexical order\n    : [...userPropsOnly];\n\n  if (haveRefProp) {\n    sortedProps.unshift('ref');\n  }\n\n  if (haveKeyProp) {\n    sortedProps.unshift('key');\n  }\n\n  return sortedProps;\n};\n", "/* @flow */\n\nexport default function createPropFilter(\n  props: {},\n  filter: string[] | ((any, string) => boolean)\n) {\n  if (Array.isArray(filter)) {\n    return (key: string) => filter.indexOf(key) === -1;\n  } else {\n    return (key: string) => filter(props[key], key);\n  }\n}\n", "/* @flow */\n\nimport spacer from './spacer';\nimport formatTreeNode from './formatTreeNode';\nimport formatProp from './formatProp';\nimport mergeSiblingPlainStringChildrenReducer from './mergeSiblingPlainStringChildrenReducer';\nimport sortPropsByNames from './sortPropsByNames';\nimport createPropFilter from './createPropFilter';\nimport type { Options } from './../options';\nimport type { ReactElementTreeNode } from './../tree';\n\nconst compensateMultilineStringElementIndentation = (\n  element,\n  formattedElement: string,\n  inline: boolean,\n  lvl: number,\n  options: Options\n) => {\n  const { tabStop } = options;\n\n  if (element.type === 'string') {\n    return formattedElement\n      .split('\\n')\n      .map((line, offset) => {\n        if (offset === 0) {\n          return line;\n        }\n\n        return `${spacer(lvl, tabStop)}${line}`;\n      })\n      .join('\\n');\n  }\n\n  return formattedElement;\n};\n\nconst formatOneChildren = (\n  inline: boolean,\n  lvl: number,\n  options: Options\n) => element =>\n  compensateMultilineStringElementIndentation(\n    element,\n    formatTreeNode(element, inline, lvl, options),\n    inline,\n    lvl,\n    options\n  );\n\nconst onlyPropsWithOriginalValue = (defaultProps, props) => propName => {\n  const haveDefaultValue = Object.keys(defaultProps).includes(propName);\n  return (\n    !haveDefaultValue ||\n    (haveDefaultValue && defaultProps[propName] !== props[propName])\n  );\n};\n\nconst isInlineAttributeTooLong = (\n  attributes: string[],\n  inlineAttributeString: string,\n  lvl: number,\n  tabStop: number,\n  maxInlineAttributesLineLength: ?number\n): boolean => {\n  if (!maxInlineAttributesLineLength) {\n    return attributes.length > 1;\n  }\n\n  return (\n    spacer(lvl, tabStop).length + inlineAttributeString.length >\n    maxInlineAttributesLineLength\n  );\n};\n\nconst shouldRenderMultilineAttr = (\n  attributes: string[],\n  inlineAttributeString: string,\n  containsMultilineAttr: boolean,\n  inline: boolean,\n  lvl: number,\n  tabStop: number,\n  maxInlineAttributesLineLength: ?number\n): boolean =>\n  (isInlineAttributeTooLong(\n    attributes,\n    inlineAttributeString,\n    lvl,\n    tabStop,\n    maxInlineAttributesLineLength\n  ) ||\n    containsMultilineAttr) &&\n  !inline;\n\nexport default (\n  node: ReactElementTreeNode,\n  inline: boolean,\n  lvl: number,\n  options: Options\n): string => {\n  const {\n    type,\n    displayName = '',\n    childrens,\n    props = {},\n    defaultProps = {},\n  } = node;\n\n  if (type !== 'ReactElement') {\n    throw new Error(\n      `The \"formatReactElementNode\" function could only format node of type \"ReactElement\". Given:  ${type}`\n    );\n  }\n\n  const {\n    filterProps,\n    maxInlineAttributesLineLength,\n    showDefaultProps,\n    sortProps,\n    tabStop,\n  } = options;\n\n  let out = `<${displayName}`;\n\n  let outInlineAttr = out;\n  let outMultilineAttr = out;\n  let containsMultilineAttr = false;\n\n  const visibleAttributeNames = [];\n\n  const propFilter = createPropFilter(props, filterProps);\n\n  Object.keys(props)\n    .filter(propFilter)\n    .filter(onlyPropsWithOriginalValue(defaultProps, props))\n    .forEach(propName => visibleAttributeNames.push(propName));\n\n  Object.keys(defaultProps)\n    .filter(propFilter)\n    .filter(() => showDefaultProps)\n    .filter(defaultPropName => !visibleAttributeNames.includes(defaultPropName))\n    .forEach(defaultPropName => visibleAttributeNames.push(defaultPropName));\n\n  const attributes = sortPropsByNames(sortProps)(visibleAttributeNames);\n\n  attributes.forEach(attributeName => {\n    const {\n      attributeFormattedInline,\n      attributeFormattedMultiline,\n      isMultilineAttribute,\n    } = formatProp(\n      attributeName,\n      Object.keys(props).includes(attributeName),\n      props[attributeName],\n      Object.keys(defaultProps).includes(attributeName),\n      defaultProps[attributeName],\n      inline,\n      lvl,\n      options\n    );\n\n    if (isMultilineAttribute) {\n      containsMultilineAttr = true;\n    }\n\n    outInlineAttr += attributeFormattedInline;\n    outMultilineAttr += attributeFormattedMultiline;\n  });\n\n  outMultilineAttr += `\\n${spacer(lvl, tabStop)}`;\n\n  if (\n    shouldRenderMultilineAttr(\n      attributes,\n      outInlineAttr,\n      containsMultilineAttr,\n      inline,\n      lvl,\n      tabStop,\n      maxInlineAttributesLineLength\n    )\n  ) {\n    out = outMultilineAttr;\n  } else {\n    out = outInlineAttr;\n  }\n\n  if (childrens && childrens.length > 0) {\n    const newLvl = lvl + 1;\n\n    out += '>';\n\n    if (!inline) {\n      out += '\\n';\n      out += spacer(newLvl, tabStop);\n    }\n\n    out += childrens\n      .reduce(mergeSiblingPlainStringChildrenReducer, [])\n      .map(formatOneChildren(inline, newLvl, options))\n      .join(!inline ? `\\n${spacer(newLvl, tabStop)}` : '');\n\n    if (!inline) {\n      out += '\\n';\n      out += spacer(newLvl - 1, tabStop);\n    }\n    out += `</${displayName}>`;\n  } else {\n    if (\n      !isInlineAttributeTooLong(\n        attributes,\n        outInlineAttr,\n        lvl,\n        tabStop,\n        maxInlineAttributesLineLength\n      )\n    ) {\n      out += ' ';\n    }\n\n    out += '/>';\n  }\n\n  return out;\n};\n", "/* @flow */\n\nimport type { Key } from 'react';\nimport formatReactElementNode from './formatReactElementNode';\nimport type { Options } from './../options';\nimport type {\n  ReactElementTreeNode,\n  ReactFragmentTreeNode,\n  TreeNode,\n} from './../tree';\n\nconst REACT_FRAGMENT_TAG_NAME_SHORT_SYNTAX = '';\nconst REACT_FRAGMENT_TAG_NAME_EXPLICIT_SYNTAX = 'React.Fragment';\n\nconst toReactElementTreeNode = (\n  displayName: string,\n  key: ?Key,\n  childrens: TreeNode[]\n): ReactElementTreeNode => {\n  let props = {};\n  if (key) {\n    props = { key };\n  }\n\n  return {\n    type: 'ReactElement',\n    displayName,\n    props,\n    defaultProps: {},\n    childrens,\n  };\n};\n\nconst isKeyedFragment = ({ key }: ReactFragmentTreeNode) => Boolean(key);\nconst hasNoChildren = ({ childrens }: ReactFragmentTreeNode) =>\n  childrens.length === 0;\n\nexport default (\n  node: ReactFragmentTreeNode,\n  inline: boolean,\n  lvl: number,\n  options: Options\n): string => {\n  const { type, key, childrens } = node;\n\n  if (type !== 'ReactFragment') {\n    throw new Error(\n      `The \"formatReactFragmentNode\" function could only format node of type \"ReactFragment\". Given: ${type}`\n    );\n  }\n\n  const { useFragmentShortSyntax } = options;\n\n  let displayName;\n  if (useFragmentShortSyntax) {\n    if (hasNoChildren(node) || isKeyedFragment(node)) {\n      displayName = REACT_FRAGMENT_TAG_NAME_EXPLICIT_SYNTAX;\n    } else {\n      displayName = REACT_FRAGMENT_TAG_NAME_SHORT_SYNTAX;\n    }\n  } else {\n    displayName = REACT_FRAGMENT_TAG_NAME_EXPLICIT_SYNTAX;\n  }\n\n  return formatReactElementNode(\n    toReactElementTreeNode(displayName, key, childrens),\n    inline,\n    lvl,\n    options\n  );\n};\n", "/* @flow */\n\nimport formatReactElementNode from './formatReactElementNode';\nimport formatReactFragmentNode from './formatReactFragmentNode';\nimport type { Options } from './../options';\nimport type { TreeNode } from './../tree';\n\nconst jsxStopChars = ['<', '>', '{', '}'];\nconst shouldBeEscaped = (s: string) =>\n  jsxStopChars.some(jsxStopChar => s.includes(jsxStopChar));\n\nconst escape = (s: string) => {\n  if (!shouldBeEscaped(s)) {\n    return s;\n  }\n\n  return `{\\`${s}\\`}`;\n};\n\nconst preserveTrailingSpace = (s: string) => {\n  let result = s;\n  if (result.endsWith(' ')) {\n    result = result.replace(/^(.*?)(\\s+)$/, \"$1{'$2'}\");\n  }\n\n  if (result.startsWith(' ')) {\n    result = result.replace(/^(\\s+)(.*)$/, \"{'$1'}$2\");\n  }\n\n  return result;\n};\n\nexport default (\n  node: TreeNode,\n  inline: boolean,\n  lvl: number,\n  options: Options\n): string => {\n  if (node.type === 'number') {\n    return String(node.value);\n  }\n\n  if (node.type === 'string') {\n    return node.value\n      ? `${preserveTrailingSpace(escape(String(node.value)))}`\n      : '';\n  }\n\n  if (node.type === 'ReactElement') {\n    return formatReactElementNode(node, inline, lvl, options);\n  }\n\n  if (node.type === 'ReactFragment') {\n    return formatReactFragmentNode(node, inline, lvl, options);\n  }\n\n  throw new TypeError(`Unknow format type \"${node.type}\"`);\n};\n", "/* @flow */\n\nimport formatTreeNode from './formatTreeNode';\nimport type { Options } from './../options';\nimport type { TreeNode } from './../tree';\n\nexport default (node: TreeNode, options: Options): string =>\n  formatTreeNode(node, false, 0, options);\n", "/* @flow */\n\nimport formatTree from './formatter/formatTree';\nimport parseReactElement from './parser/parseReactElement';\nimport type { Element as ReactElement } from 'react';\nimport type { Options } from './options';\n\nconst reactElementToJsxString = (\n  element: ReactElement<any>,\n  {\n    filterProps = [],\n    showDefaultProps = true,\n    showFunctions = false,\n    functionValue,\n    tabStop = 2,\n    useBooleanShorthandSyntax = true,\n    useFragmentShortSyntax = true,\n    sortProps = true,\n    maxInlineAttributesLineLength,\n    displayName,\n  }: Options = {}\n) => {\n  if (!element) {\n    throw new Error('react-element-to-jsx-string: Expected a ReactElement');\n  }\n\n  const options = {\n    filterProps,\n    showDefaultProps,\n    showFunctions,\n    functionValue,\n    tabStop,\n    useBooleanShorthandSyntax,\n    useFragmentShortSyntax,\n    sortProps,\n    maxInlineAttributesLineLength,\n    displayName,\n  };\n\n  return formatTree(parseReactElement(element, options), options);\n};\n\nexport default reactElementToJsxString;\n\nexport {\n  inlineFunction,\n  preserveFunctionLineBreak,\n} from './formatter/formatFunction';\n"],
  "mappings": "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",
  "names": ["prettyPrint", "ForwardRef", "Fragment", "Memo", "isContextConsumer", "isContextProvider", "isForwardRef", "isLazy", "isMemo", "isProfiler", "isStrictMode", "isSuspense", "times", "tabStop", "Array", "fill", "join", "safeSortObject", "value", "seen", "Date", "RegExp", "isValidElement", "add", "isArray", "map", "v", "Object", "keys", "sort", "reduce", "result", "key", "has", "sortObject", "WeakSet", "createStringTreeNode", "type", "createNumberTreeNode", "createReactElementTreeNode", "displayName", "props", "defaultProps", "childrens", "createReactFragmentTreeNode", "supportFragment", "Boolean", "Fragment", "getFunctionTypeName", "functionType", "name", "getWrappedComponentDisplayName", "Component", "$$typeof", "Memo", "ForwardRef", "render", "getReactElementDisplayName", "element", "isForwardRef", "isMemo", "isContextConsumer", "_context", "isContextProvider", "isLazy", "isProfiler", "isStrictMode", "isSuspense", "noChildren", "propsValue", "propName", "onlyMeaningfulChildren", "children", "filterProps", "originalProps", "cb", "filteredProps", "filter", "forEach", "parseReactElement", "options", "displayNameFn", "React", "Error", "ref", "search", "Children", "toArray", "child", "noRefCheck", "inlineFunction", "fn", "toString", "split", "line", "trim", "preserveFunctionLineBreak", "defaultFunctionValue", "functionValue", "showFunctions", "inline", "lvl", "normalizedValue", "stringifiedValue", "prettyPrint", "transform", "currentObj", "prop", "originalResult", "currentValue", "formatTreeNode", "formatFunction", "replace", "spacer", "escape", "s", "formatPropValue", "propValue", "String", "symbolDescription", "valueOf", "isNaN", "toISOString", "isPlainObject", "formatComplexDataStructure", "hasValue", "hasDefaultValue", "defaultValue", "usedValue", "useBooleanShorthandSyntax", "formattedPropValue", "attributeFormattedInline", "attributeFormattedMultiline", "isMultilineAttribute", "includes", "previousNodes", "currentNode", "nodes", "slice", "length", "previousNode", "push", "isKeyOrRefProps", "shouldSortUserProps", "haveKeyProp", "haveRefProp", "userPropsOnly", "oneProp", "sortedProps", "unshift", "createPropFilter", "indexOf", "compensateMultilineStringElementIndentation", "formattedElement", "offset", "formatOneChildren", "onlyPropsWithOriginalValue", "haveDefaultValue", "isInlineAttributeTooLong", "attributes", "inlineAttributeString", "maxInlineAttributesLineLength", "shouldRenderMultilineAttr", "containsMultilineAttr", "node", "showDefaultProps", "sortProps", "out", "outInlineAttr", "outMultilineAttr", "visibleAttributeNames", "propFilter", "defaultPropName", "sortPropsByNames", "attributeName", "formatProp", "newLvl", "mergeSiblingPlainStringChildrenReducer", "REACT_FRAGMENT_TAG_NAME_SHORT_SYNTAX", "REACT_FRAGMENT_TAG_NAME_EXPLICIT_SYNTAX", "toReactElementTreeNode", "isKeyedFragment", "hasNoChildren", "useFragmentShortSyntax", "formatReactElementNode", "jsxStopChars", "shouldBeEscaped", "some", "jsxStopChar", "preserveTrailingSpace", "endsWith", "startsWith", "formatReactFragmentNode", "TypeError", "reactElementToJsxString", "formatTree"]
}
